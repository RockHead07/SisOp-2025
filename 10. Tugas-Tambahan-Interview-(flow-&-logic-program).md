<div align="center">

# LAPORAN RESMI SISTEM OPERASI
### Minggu ke-10

---

![Image](https://github.com/user-attachments/assets/3ad88b6e-7159-44a2-a004-c909b974a88c)

#### Dosen Pengampu :
**Dr. Ferry Astika Saputra ST, M.Sc.**

#### Disusun Oleh : 
**Bagus Insan Pradana** D3 IT A **(3214521007)**

> PROGRAM STUDI D3 TEKNIK INFORMATIKA PSDKU LAMONGAN
> DEPARTEMEN TEKNIK INFORMATIKA DAN KOMPUTER 
> POLITEKNIK ELEKTRONIKA NEGERI SURABAYA 
> 2025

</div>

---

# üìñ Penugasan

- Penugasan tambahan pada mata kuliah `SisOp-2025` sebelumnya di **practice exercise S10-Ch05**
- Dan pada penugasan kali ini, akan diadakan interview yang dimana topik interviewnya adalah ***flow dari logic program tersebut***.
- Penugasan tersebut sama seperti pengerjaan tugas pertemuan sebelumnya. Yaitu, mencari soal pada **practice exercise S10-Ch05** yang mencangkup algoritma shceduling ini: `SJF Scheduling Algorithm Without Arrival Time (Non-Preemptive)`, `SJF Scheduling Algorithm with Arrival Time (Non-Preemptive)`, & `SRTF (Shortest Remaining Time First) Scheduling Algorithm (Preemptive)`.
- Cari 3 soal saja & apabila memungkinkan beri penjelasan logic dari flow program tersebut!

---

# ‚ö†Ô∏è Tidak Ditemukan Kasus *algorithm scheduling* Seperti Minggu Kemarin.

**Saya tegaskan kembali**, bahwa tidak ada kasus *algoritma shceduling* `SJF Scheduling Algorithm Without Arrival Time (Non-Preemptive)`, `SJF Scheduling Algorithm with Arrival Time (Non-Preemptive)`, & `SRTF (Shortest Remaining Time First) Scheduling Algorithm (Preemptive)` pada bagian *practice exercises*! 

Jadi saya akan mengambil asumsi bahwa PPT `S10-Ch05` tidak relevan dengan perintah penugasan pada pertemuan kali ini. Jadi saya akan membuat ulang penugasan minggu lalu yang agak serupa, namun beda dengan persoalan kasus ***algoritma scheduling*** minggu sebelumnya. 

---

# Simulasi Penjadwalan CPU: Algoritma Priority Scheduling (Preemptive)

## üìå Studi Kasus Simulasi

Simulasi ini bertujuan untuk memodelkan bagaimana proses-proses dieksekusi oleh CPU menggunakan algoritma **priority scheduling dengan preemption**. Setiap proses memiliki informasi waktu kedatangan (*arrival time*), durasi eksekusi (*burst time*), dan tingkat prioritas.

Tingkat prioritas menggunakan angka: semakin kecil angkanya, semakin tinggi prioritasnya.

### Data Proses

```
Proses | Waktu Kedatangan | Burst Time | Prioritas
-------|------------------|------------|----------
P1     |        0         |     4      |    2
P2     |        1         |     3      |    1
P3     |        2         |     1      |    3
```

## üßÆ Penjelasan Algoritma Priority (Preemptive)

* Proses yang memiliki **prioritas lebih tinggi** (angka prioritas lebih kecil) akan mendapatkan giliran eksekusi terlebih dahulu.
* Jika ada proses baru yang masuk dan memiliki prioritas **lebih tinggi** dari proses yang sedang berjalan, maka proses saat ini akan dihentikan sementara (preempted), dan proses baru tersebut akan dijalankan.
* Eksekusi dilakukan secara unit per waktu (per satuan detik).

---

## üß† Ringkasan Konsep Penjadwalan CPU

### 1. **FCFS (First Come First Serve)**

* Proses diproses sesuai urutan kedatangannya.
* Tidak bisa diinterupsi (non-preemptive).
* Kelemahannya adalah proses lambat di awal bisa menyebabkan penundaan bagi proses lain.

### 2. **SJF (Shortest Job First)**

* Proses dengan waktu burst terkecil dijalankan lebih dahulu.
* Dapat bersifat preemptive (SRTF) atau non-preemptive.
* Efektif untuk mengurangi rata-rata waktu tunggu, tapi bisa menyebabkan starvation.

### 3. **Round Robin**

* Setiap proses diberi alokasi waktu (time quantum) secara bergilir.
* Preemptive secara default: proses akan digantikan setelah quantum habis.
* Cocok untuk sistem interaktif dan multitasking.

### 4. **Priority Scheduling**

* Penjadwalan berdasarkan urutan prioritas.
* Proses baru bisa langsung dijalankan jika memiliki prioritas lebih tinggi (preemptive).
* Jika dua proses memiliki prioritas sama, maka FCFS dapat digunakan sebagai tie-breaker.

---

## üîÑ Simulasi Eksekusi: Priority Preemptive Scheduling

### Gantt Chart Eksekusi

```
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
|---|---|---|---|---|---|---|---|---|
| P1| P2| P2| P2| P1| P1| P1| P3|   |
```

### Penjelasan Waktu Eksekusi

* **Waktu 0:** Proses P1 mulai karena merupakan satu-satunya yang tersedia.
* **Waktu 1:** P2 tiba dan memiliki prioritas lebih tinggi dari P1, maka P1 di-preempt.
* **Waktu 1-4:** P2 dieksekusi hingga selesai.
* **Waktu 4-7:** P1 melanjutkan sisa burst-nya.
* **Waktu 7-8:** P3 masuk dan langsung diselesaikan karena tidak ada proses lain.

### Rekapitulasi Proses

```
Proses | Arrival | Burst | Prioritas | Selesai | Turnaround | Waiting
P1     |   0     |   4   |     2     |   7     |     7      |   3
P2     |   1     |   3   |     1     |   4     |     3      |   0
P3     |   2     |   1   |     3     |   8     |     6      |   5
```

**Rata-rata Turnaround Time:** (7 + 3 + 6) / 3 = 5.33
**Rata-rata Waiting Time:** (3 + 0 + 5) / 3 = 2.67

---

## üíª Implementasi Program dalam Bahasa C

```c
#include <stdio.h>

#define MAX 10

typedef struct {
    int id, arrival, burst, remaining, priority;
    int finish, turnaround, waiting;
} Process;

int main() {
    Process p[3] = {
        {1, 0, 4, 4, 2},
        {2, 1, 3, 3, 1},
        {3, 2, 1, 1, 3}
    };

    int time = 0, completed = 0, n = 3;

    while (completed < n) {
        int current = -1;
        for (int i = 0; i < n; i++) {
            if (p[i].arrival <= time && p[i].remaining > 0) {
                if (current == -1 || p[i].priority < p[current].priority)
                    current = i;
            }
        }

        if (current != -1) {
            p[current].remaining--;
            if (p[current].remaining == 0) {
                p[current].finish = time + 1;
                completed++;
            }
        }
        time++;
    }

    float totalTAT = 0, totalWT = 0;
    printf("Proses | Arrival | Burst | Priority | Finish | TAT | WT\n");
    for (int i = 0; i < n; i++) {
        p[i].turnaround = p[i].finish - p[i].arrival;
        p[i].waiting = p[i].turnaround - p[i].burst;
        totalTAT += p[i].turnaround;
        totalWT += p[i].waiting;
        printf("P%d     |   %d      |   %d   |    %d     |   %d    |  %d  | %d\n",
               p[i].id, p[i].arrival, p[i].burst, p[i].priority,
               p[i].finish, p[i].turnaround, p[i].waiting);
    }

    printf("\nRata-rata TAT: %.2f\n", totalTAT / n);
    printf("Rata-rata WT : %.2f\n", totalWT / n);
    return 0;
}
```

Berikut output pada implementasi dari perintah tersebut:

```
Proses | Arrival | Burst | Priority | Finish | TAT | WT
P1     |   0      |   4   |    2     |   7    |  7  | 3
P2     |   1      |   3   |    1     |   4    |  3  | 0
P3     |   2      |   1   |    3     |   8    |  6  | 5

Rata-rata TAT: 5.33
Rata-rata WT : 2.67
```

---

## üìä Pemahaman Alur Program

### Tahap 1: Persiapan dan Inisialisasi

* Data proses dimasukkan langsung ke dalam array.
* Sisa waktu (`remaining`) diinisialisasi sama dengan burst time.

### Tahap 2: Eksekusi Simulasi

* Waktu berjalan mulai dari 0.
* Pada setiap unit waktu:

  * Cek proses yang telah datang dan belum selesai.
  * Pilih proses dengan prioritas tertinggi.
  * Jalankan selama 1 unit waktu dan kurangi sisa waktunya.
  * Jika proses selesai, catat waktu selesai.

### Tahap 3: Penghitungan dan Output

* Hitung Turnaround Time dan Waiting Time per proses.
* Hitung total dan rata-rata dari TAT dan WT.
* Cetak hasil ke layar.

---

## ‚úÖ Kesimpulan Akhir

Priority Scheduling (Preemptive) adalah strategi penjadwalan yang efisien ketika proses memiliki bobot kepentingan berbeda. Dengan melakukan preempt saat proses dengan prioritas lebih tinggi datang, sistem bisa memberikan waktu eksekusi kepada proses penting lebih cepat.

Kelebihannya:

* Menjamin proses penting diprioritaskan.
* Dapat menangani proses real-time.

Namun juga memiliki kekurangan:

* Bisa menyebabkan starvation terhadap proses berprioritas rendah.

Simulasi ini menunjukkan cara algoritma bekerja secara praktikal dan bagaimana waktu tunggu dan penyelesaian dihitung untuk mengevaluasi performa penjadwalan.

---


